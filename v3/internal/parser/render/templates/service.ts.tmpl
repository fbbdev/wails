{{$module := .}}
{{- $models := $module.ModelsFile}}
{{- $internal := $module.InternalFile}}
{{- $useNames := $module.UseNames}}
{{- $useInterfaces := $module.UseInterfaces}}
{{- $useBundle := .UseBundledRuntime}}
{{- $imports := $module.Imports}}
{{- with .Service -}}
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT
{{if or (hasdoc .Decl.Doc) (hasdoc .Doc)}}
/**
{{- if hasdoc .Decl.Doc}}
{{- jsdoc .Decl.Doc.Text ""}}{{if hasdoc .Doc}}
 *{{end}}
{{- end}}
{{- if hasdoc .Doc}}
{{- jsdoc .Doc.Text ""}}
{{- end}}
 * @module
 */
{{end}}
import {Call as $Call, Types as $Types} from {{if $useBundle}}"/wails/runtime.js"{{else}}"{{js $imports.Core}}/index.js"{{end}};
{{- if and .Injections .ImportRuntime}}
import * as $runtime from {{if $useBundle}}"/wails/runtime.js"{{else}}"{{js $imports.Runtime}}/index.js"{{end}};
{{- end}}
{{range $imports.External}}
import * as {{jsimport .}} from "{{js .RelPath}}/{{js $models}}";
{{- end}}{{if $imports.External}}
{{end}}
{{- if $imports.ImportModels}}
import * as $models from "./{{js $models}}";{{if not $imports.ImportInternal}}
{{end}}{{end}}
{{- if $imports.ImportInternal}}
import * as $internal from "./{{js $internal}}";
{{end}}
{{- range .Injections}}
{{.}}
{{- end}}{{if .Injections}}
{{end}}
{{- range .Methods}}
{{- if or (hasdoc .Decl.Doc) (hasdoc .Doc)}}
/**
{{- if hasdoc .Decl.Doc}}
{{- jsdoc .Decl.Doc.Text ""}}{{if hasdoc .Doc}}
 *{{end}}
{{- end}}
{{- if .Doc}}
{{- jsdoc .Doc.Text ""}}
{{- end}}
 */
{{- end}}
{{if not .Internal}}export {{end}}function {{.Name}}({{range $i, $param := .Params -}}
    {{- if gt $i 0}}, {{end}}
    {{- if .Variadic}}...{{end}}
    {{- jsparam $i .}}: {{$module.JSType .Type}}{{if .Variadic}}[]{{end}}
{{- end}}): Promise<
    {{- if eq 0 (len .Results) -}}
        void
    {{- else if eq 1 (len .Results)}}
        {{- $module.JSType (index .Results 0)}}
    {{- else -}}
        [{{range $i, $result := .Results}}
            {{- if gt $i 0}}, {{end}}
            {{- $module.JSType $result}}
        {{- end}}]
    {{- end}}> & { cancel(): void } {
    {{- if $useNames}}
    let $resultPromise = $Call.ByName("{{js .FQN}}"
    {{- else}}
    let $resultPromise = $Call.ByID({{.ID}}
    {{- end}}{{range $i, $param := .Params}}, {{$garble := ($module.JSGarble .Type)}}
        {{- if ne $garble "$Types.GarbleAny"}}{{$garble}}({{end}}
        {{- jsparam $i .}}
        {{- if ne $garble "$Types.GarbleAny"}}){{end}}
    {{- end}}) as any;
    {{- if or (not .Results) (and $useInterfaces ($module.SkipUngarble .Results)) (and (not $useInterfaces) ($module.SkipCreate .Results))}}
    return $resultPromise;
    {{- else if $useInterfaces}}
    let $ungarblePromise = $resultPromise.then(($result) => {
    {{- if eq 1 (len .Results)}}
        return {{$module.JSUngarble (index .Results 0)}}($result);
    {{- else}}
        {{- range $i, $type := .Results}}
        {{- $ungarble := ($module.JSUngarble $type)}}
        {{- if ne $ungarble "$Types.UngarbleAny"}}
        $result[{{$i}}] = {{$ungarble}}($result[{{$i}}]);
        {{- end}}{{end}}
        return $result;
    {{- end}}
    }) as any;
    $ungarblePromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $ungarblePromise;
    {{- else}}
    let $typingPromise = $resultPromise.then(($result) => {
    {{- if eq 1 (len .Results)}}
        return {{$module.JSCreate (index .Results 0)}}($result);
    {{- else}}
        {{- range $i, $type := .Results}}
        {{- $create := ($module.JSCreate $type)}}
        {{- if ne $create "$Types.CreateAny"}}
        $result[{{$i}}] = {{$create}}($result[{{$i}}]);
        {{- end}}{{end}}
        return $result;
    {{- end}}
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
    {{- end}}
}
{{end}}
{{- $deferred := $module.DeferredCreates}}
{{- if hasnonempty $deferred}}
// Private type creation functions
{{- range $i, $create := $deferred}}{{if $create}}
{{if and (ge (len $create) 15) (eq (slice $create 0 15) "function $$init")}}var {{else}}const {{end -}}
$$createType{{$i}} = {{$create}};
{{- end}}{{end}}
{{end}}
{{- $deferred = $module.DeferredGarbles}}
{{- if hasnonempty $deferred}}
// Private type garbling functions
{{- range $i, $garble := $deferred}}{{if $garble}}
{{if and (ge (len $garble) 15) (eq (slice $garble 0 15) "function $$init")}}var {{else}}const {{end -}}
$$garbleType{{$i}} = {{$garble}};
{{- end}}{{end}}
{{end}}
{{- $deferred = $module.DeferredUngarbles}}
{{- if hasnonempty $deferred}}
// Private type ungarbling functions
{{- range $i, $ungarble := $deferred}}{{if $ungarble}}
{{if and (ge (len $ungarble) 15) (eq (slice $ungarble 0 15) "function $$init")}}var {{else}}const {{end -}}
$$ungarbleType{{$i}} = {{$ungarble}};
{{- end}}{{end}}
{{end}}{{end -}}
