{{$module := .}}
{{- $runtime := $module.Runtime}}
{{- $models := $module.ModelsFile}}
{{- $internal := $module.InternalFile}}
{{- $useInterfaces := .UseInterfaces}}
{{- $imports := $module.Imports -}}
// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

import {Types as $Types} from "{{js $runtime}}";
{{range $imports.External}}
import * as {{jsimport .}} from "{{js .RelPath}}/{{js $models}}";
{{- end}}{{if $imports.External}}
{{end}}
{{- if $imports.ImportModels}}
import * as $models from "./{{js $models}}";{{if not $imports.ImportInternal}}
{{end}}{{end}}
{{- if $imports.ImportInternal}}
import * as $internal from "./{{js $internal}}";
{{end}}
{{- range $model := .Models}}

{{- $isEnum := $model.Values}}
{{- $isClassAlias := and $model.Type (not $useInterfaces) (isclass $model.Type)}}
{{- $isTypeAlias := and $model.Type (or $useInterfaces (not (isclass $model.Type)))}}
{{- $isClassOrInterface := and (not $model.Type) (not $model.Values)}}
{{- $isInterface := and $isClassOrInterface (or $useInterfaces $model.Alias)}}

{{- /* Build type parameter list */}}
{{- $typeParams := ""}}
{{- $typeParamList := ""}}
{{- $createParamList := ""}}
{{- $garbleParamList := ""}}
{{- range $i, $param := $model.TypeParams}}
    {{- $param = (typeparam $i $param)}}
    {{- if eq $i 0}}
        {{- $typeParams = $param}}
        {{- $typeParamList = (printf "<%s" $param)}}
        {{- $createParamList = (printf "($$createParam%s" $param)}}
        {{- $garbleParamList = (printf "($$garbleParam%s" $param)}}
    {{- else}}
        {{- $typeParams = (printf "%s,%s" $typeParams $param)}}
        {{- $typeParamList = (printf "%s, %s" $typeParamList $param)}}
        {{- $createParamList = (printf "%s, $$createParam%s" $createParamList $param)}}
        {{- $garbleParamList = (printf "%s, $$garbleParam%s" $garbleParamList $param)}}
    {{- end}}
{{- end}}
{{- if $typeParamList}}
    {{- $typeParamList = (printf "%s>" $typeParamList)}}
    {{- $createParamList = (printf "%s)" $createParamList)}}
    {{- $garbleParamList = (printf "%s)" $garbleParamList)}}
{{- end}}

{{- if or $typeParamList (hasdoc $model.Decl.Doc) (hasdoc $model.Doc) $isEnum $isTypeAlias $isInterface}}
/**
{{- if hasdoc $model.Decl.Doc}}
{{- jsdoc $model.Decl.Doc.Text ""}}{{if hasdoc $model.Doc}}
 *{{end}}
{{- end}}
{{- if hasdoc $model.Doc}}
{{- jsdoc $model.Doc.Text ""}}
{{- end}}
{{- if and $typeParamList (not $isClassAlias)}}
 * @template {{$typeParams}}
{{- end}}
{{- if $isEnum}}
 * @readonly
 * @enum { {{- $module.JSType $model.Type -}} }
{{- else if $isTypeAlias}}
 * @typedef { {{- $module.JSType $model.Type -}} } {{jsid $model.Name}}
{{- else if $isInterface}}
{{- if isjsdocobj $model}}
 * @typedef {Object} {{jsid $model.Name}}
{{- range $i, $decl := $model.Fields}}{{range $j, $field := $decl}}
 * @property { {{- $module.JSFieldType $field.StructField -}} }
    {{- if $field.Optional}} [{{else}} {{end}}{{$field.JSName}}{{if $field.Optional}}]{{end}}
    {{- if hasdoc $field.Decl.Doc}} - {{jsdocline $field.Decl.Doc.Text}}{{end}}
{{- end}}{{end}}
{{- else}}
 * @typedef { {
{{- range $i, $decl := $model.Fields}}{{range $j, $field := $decl}}
 *     "{{js $field.JSName}}"{{if $field.Optional}}?{{end}}: {{$module.JSFieldType $field.StructField}},
{{- end}}{{end}}
 * } } {{jsid $model.Name}}
{{- end}}
{{- end}}
 */
{{- end}}
{{- if $isEnum}}
export const {{jsid $model.Name}} = {
    {{- range $i, $decl := $model.Values}}{{range $j, $spec := $decl}}{{range $k, $value := $spec}}
    {{- if and (ne $i 0) (eq $j 0) (eq $k 0)}}
{{end}}
    {{- if or (and (eq $j 0) (eq $k 0) (hasdoc $value.Decl.Doc)) (and (eq $k 0) (hasdoc $value.Spec.Doc))}}
    {{- if gt $j 0}}
{{end}}
    /**
    {{- if and (eq $j 0) (eq $k 0) (hasdoc $value.Decl.Doc)}}
    {{- jsdoc $value.Decl.Doc.Text "    "}}{{if and (eq $k 0) (hasdoc $value.Spec.Doc)}}
     *{{end}}
    {{- end}}
    {{- if and (eq $k 0) (hasdoc $value.Spec.Doc)}}
    {{- jsdoc $value.Spec.Doc.Text "    "}}
    {{- end}}
     */
    {{- end}}
    {{jsid $value.Name}}: {{jsvalue $value.Value}},
    {{- end}}{{end}}{{end}}
};
{{else if $isClassAlias}}
export const {{jsid $model.Name}} = {{$module.JSType $model.Type.Origin}};

/**
{{- if hasdoc $model.Decl.Doc}}
{{- jsdoc $model.Decl.Doc.Text ""}}{{if hasdoc $model.Doc}}
 *{{end}}
{{- end}}
{{- if hasdoc $model.Doc}}
{{- jsdoc $model.Doc.Text ""}}
{{- end}}
{{- if $typeParamList}}
 * @template {{$typeParams}}
{{- end}}
 * @typedef { {{- $module.JSType $model.Type -}} } {{jsid $model.Name}}
 */
{{else if and $isClassOrInterface (not $isInterface)}}
export class {{jsid $model.Name}} {
    /**
     * Creates a new {{jsid $model.Name}} instance.
     * @param {Partial<{{jsid $model.Name}}{{$typeParamList}}>} [$$source = {}] - The source object to create the {{jsid $model.Name}}.
     */
    constructor($$source = {}) {
    {{- range $decl := $model.Fields}}{{range $j, $field := $decl}}
        {{- /*
            In JS we need to set all properties explicitly
            because JSDoc has no support for arbitrary property names yet.
            See https://github.com/jsdoc/jsdoc/issues/1468

            For optional fields we make the initialization code unreachable
            and cast the false condition to any to prevent any complaint from Typescript.
        */}}
        if ({{if $field.Optional}}/** @type {any} */(false){{else}}!("{{js $field.JSName}}" in $$source){{end}}) {
            /**
            {{- if and (eq $j 0) (hasdoc $field.Decl.Doc)}}
            {{- jsdoc $field.Decl.Doc.Text "            "}}
            {{- end}}
             * @member
             * @type { {{- $module.JSFieldType $field.StructField}}{{if .Optional}} | undefined{{end -}} }
             */
            this["{{js $field.JSName}}"] = {{$module.JSDefault $field.Type $field.Quoted}};
        }
    {{- end}}{{end}}

        Object.assign(this, $$source);
    }

    /**
    {{- if $typeParamList}}
     * Given creation functions for each type parameter,
     * returns a creation function for a concrete instance
     * of the generic class {{jsid $model.Name}}.
     * @template {{$typeParams}}
    {{- range $i, $param := $model.TypeParams}}
        {{- $param = (typeparam $i $param)}}
     * @param {(any) => {{$param -}} } $$createParam{{$param}}
    {{- end}}
     * @returns {($$source?: any) => {{jsid $model.Name}}{{$typeParamList -}} }
    {{- else}}
     * Creates a new {{jsid $model.Name}} instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns { {{- jsid $model.Name -}} }
    {{- end}}
     */
    static createFrom{{if $typeParamList}}{{$createParamList}}{{else}}($$source = {}){{end}} {
        {{- range $i, $spec := $model.Fields}}{{range $j, $field := $spec}}
            {{- $create := ($module.JSCreateWithParams $field.Type $createParamList)}}
            {{- if ne $create "$Types.CreateAny"}}
        const $$createField{{$i}}_{{$j}} = {{$create}};
            {{- end}}
        {{- end}}{{end}}
        {{- $indent := ""}}
        {{- if $typeParamList}}
            {{- $indent = "    "}}
        return ($$source = {}) => {
        {{- end}}
        {{$indent}}let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        {{- if $module.IsGarbledModel $model}}
        {{$indent}}$$parsedSource = {{jsid $model.Name}}._ungarble($$parsedSource);
        {{- end}}
        {{- range $i, $spec := $model.Fields}}{{range $j, $field := $spec}}
            {{- if $module.NeedsCreate $field.Type}}
        {{$indent}}if ("{{js $field.JSName}}" in $$parsedSource) {
        {{$indent}}    $$parsedSource["{{js $field.JSName}}"] = $$createField{{$i}}_{{$j}}($$parsedSource["{{js $field.JSName}}"]);
        {{$indent -}} }
            {{- end}}
        {{- end}}{{end}}
        {{$indent}}return new {{jsid $model.Name}}(/** @type {Partial<{{jsid $model.Name}}{{$typeParamList}}>} */($$parsedSource));
        {{- if $typeParamList}}
        };
        {{- end}}
    }
    {{- if $module.IsGarbledModel $model}}
    /**
    {{- if $typeParamList}}
     * Given garbling functions for each type parameter,
     * returns a garbling function for a concrete instance
     * of the generic class {{jsid $model.Name}}.
     * @template {{$typeParams}}
    {{- range $i, $param := $model.TypeParams}}
        {{- $param = (typeparam $i $param)}}
     * @param {({{$param}}) => any } $$garbleParam{{$param}}
    {{- end}}
     * @returns {($$instance: {{jsid $model.Name}}{{$typeParamList}}) => any }
    {{- else}}
     * Garbles a {{jsid $model.Name}} instance.
     * @param { {{- jsid $model.Name -}} } $$instance
     * @returns {any}
    {{- end}}
     */
    static garble{{if $typeParamList}}{{$garbleParamList}}{{else}}($$instance){{end}} {
        {{- range $i, $spec := $model.Fields}}{{range $j, $field := $spec}}
            {{- $garble := ($module.JSGarbleWithParams $field.Type $garbleParamList)}}
            {{- if ne $garble "$Types.GarbleAny"}}
        const $$garbleField{{$i}}_{{$j}} = {{$garble}};
            {{- end}}
        {{- end}}{{end}}
        {{- $indent := ""}}
        {{- if $typeParamList}}
            {{- $indent = "    "}}
        return ($$instance) => {
        {{- end}}
        {{$indent}}const $$result = {};
        {{- range $i, $spec := $model.Fields}}{{range $j, $field := $spec}}
        {{$indent}}if ("{{js $field.JSName}}" in $$instance) {
            {{- if $module.IsGarbled $field.Type}}
        {{$indent}}    $$result["{{js $field.JsonName}}"] = $$garbleField{{$i}}_{{$j}}($$instance["{{js $field.JSName}}"]);
            {{- else}}
        {{$indent}}    $$result["{{js $field.JsonName}}"] = $$instance["{{js $field.JSName}}"];
            {{- end}}
        {{$indent -}} }
        {{- end}}{{end}}
        {{$indent}}return $$result;
        {{- if $typeParamList}}
        };
        {{- end}}
    }

    /**
     * Ungarbling function for {{jsid $model.Name}}.
     * @private
     * @param {any} $$source
     * @returns {any}
     */
    static _ungarble($$source) {
        const $$result = {};
        {{- range $i, $spec := $model.Fields}}{{range $j, $field := $spec}}
        if ("{{js $field.JsonName}}" in $$source) {
            $$result["{{js $field.JSName}}"] = $$source["{{js $field.JsonName}}"];
        }
        {{- end}}{{end}}
        return $$result;
    }
    {{- end}}
}
{{else}}
{{- /* Rendered as a @typedef */}}
{{end}}
{{- end}}
{{- $deferred := $module.DeferredCreates}}
{{- if $deferred}}
// Private type creation functions
{{- range $i, $create := $deferred}}
{{if and (ge (len $create) 15) (eq (slice $create 0 15) "function $$init")}}var {{else}}const {{end -}}
$$createType{{$i}} = {{$create}};
{{- end}}
{{end}}
{{- $deferred = $module.DeferredGarbles}}
{{- if $deferred}}
// Private type garbling functions
{{- range $i, $garble := $deferred}}
{{if and (ge (len $garble) 15) (eq (slice $garble 0 15) "function $$init")}}var {{else}}const {{end -}}
$$garbleType{{$i}} = {{$garble}};
{{- end}}
{{end -}}
